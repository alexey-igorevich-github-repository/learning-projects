import java.util.ArrayList; // импортируем класс ArrayList из стандартной библиотеки java.util для работы с динамическими массивами
import java.util.List; // импортируем интерфейс List из стандартной библиотеки java.util для изменения поведения списков и больше гибкости кода
import java.util.Scanner; // импортируем класс Scanner из стандартной библиотеки java.util для считывания пользовательского ввода


interface Figure { // объявим интерфейс с именем Figure, он будет описывать поведение, но при этом не содержать реализации
    double calculate_figure_area(); // определим методы, которые будут реализованы в классах-насдедниках. метод для расчета площади
    void print_figure_info(); // определим методы, которые будут реализованы в классах-насдедниках. метод для вывода информации о фигуре
} // конец блока описани интерфейса Figure


class Triangle implements Figure { // объявим класс Triangle, для последующего создания объектов Triangle, который будет реализовывать интерфейс Figure
    private double base; // объявим поле base типа double в private scope для хранения значения длинны основания треугольника
    private double height; // объявим поле height типа double в private scope для хранения значения высоты треугольника

    public Triangle(double base, double height) { // объявим конструктор Triangle, принимающий параметры base типа double и height типа double
        this.base = base; // проинициализируем поле base в private scope переданным аргументом base из конструктора
        this.height = height;// проинициализируем поле height в private scope переданным аргументом height из конструктора
    } // конец блока описания конструктора класса Triangle 

    @Override // аннотация для переопредления метода из интерфейса или же родительского класса. аннотация гарантирует правильное переопределение метода
    public double calculate_figure_area() { // переопределим метод calculate_figure_area() так, чтобы он вычислял именно площадь треугольника (объекта класса Triangle)
        return 0.5 * base * height; // вернем посчитанную по формуле площади треугольника значение
    } // конец переопределения метода calculate_figure_area()

    @Override // аннотация для переопредления метода из интерфейса или же родительского класса. аннотация гарантирует правильное переопределение метода
    public void print_figure_info() { // переопределим метод print_figure_info() так, чтобы он выводил информацию именно об объектах класса Triangle
        System.out.println("Треугольник: основание = " + base + ", высота = " + height + ", площадь = " + calculate_figure_area()); // выведем информацию об объекта класса Triangle с использованием соответствующих переменных и заранее переопределенного метода для подсчета плозади.        
    } // конец переопределения метода print_figure_info()
} // конец определения класса Triangle


class Square implements Figure {  // объявим класс Square, для последующего создания объектов Square, который будет реализовывать интерфейс Figure
    private double side; // объявим поле side типа double в private scope для хранения значения длинны стороны квадрата

    public Square(double side) { // объявим конструктор Square, принимающий параметр side типа double
        this.side = side; // проинициализируем поле side в private scope переданным аргументом side из конструктора
    } // конец блока описания конструктора класса Square

    @Override // аннотация для переопредления метода из интерфейса или же родительского класса. аннотация гарантирует правильное переопределение метода
    public double calculate_figure_area() { // переопределим метод calculate_figure_area() так, чтобы он вычислял именно площадь квадрата (объекта класса Square)
        return side * side; // вернем посчитанную по формуле площади квадрата значение
    } // конец переопределения метода calculate_figure_area()

    @Override // аннотация для переопредления метода из интерфейса или же родительского класса. аннотация гарантирует правильное переопределение метода
    public void print_figure_info() { // переопределим метод print_figure_info() так, чтобы он выводил информацию именно об объектах класса Square
        System.out.println("Квадрат: сторона = " + side + ", площадь = " + calculate_figure_area()); // выведем информацию об объекте класса Square с использованием соответствующей переменной и заранее переопределенного метода для подсчета площади.
    } // конец переопределения метода print_figure_info()
} // конец определения класса Square


class SearchInfo { // объявим класс SearchInfo для поиска фигур по площади
    public static void filter_figures(List<Figure> figures, double the_comparison_value, boolean looking_for_bigger_value) { // объявим статический метод filter_figures() в public scope который будет сравнивать фигуры по условию с заданным значением площади из переменной the_comparison_value. Принимает массив объектов фигур, значение для сравнения, и булево значение, от которого зависит в какую сторону ищем.
        for (Figure figure : figures) { // определим цикл for который будет перебирать все фигуры из массива figures и выполнять необходимые действия внутри (выход на результатирующее TRUE после чего сравнение с заданной пользователем пороговой площадью the_comparison_value)
            if ((looking_for_bigger_value && figure.calculate_figure_area() > the_comparison_value) ||  // TRUE(1) && (S_фигуры > S_для_сопоставления)
                (!looking_for_bigger_value && figure.calculate_figure_area() < the_comparison_value)) { // (не_FALSE(0) т.е.== TRUE) && (S_фигуры < S_для_сопоставления)
                figure.print_figure_info(); // выведем найденную фигуру. выполнится в том случае, если в наличии будут подходящие объекты фигур.
            } // конец определения  условия фильтраци выводимых фигур и вывода.
        } // конец определения  цикла for
    } // конец определения метода filter_figures()
} // конец определения класса SearchInfo


public class Main { // объявим класс Main в public scope который является точкой входа в программу
    public static void main(String[] args) { // объявим главный метод программы main в public scope который возвращает void. метод статичный, для вызова не нужен объект. принимает массив аргрументов при запуске. JVM начинает выполнение программы с этого метода. JVM требует стандартной сигнатуры метода main()
        Scanner scanner = new Scanner(System.in); // создадим новй объект scanner класса Scanner, который будет считывать данные из консоли (пользовательский ввод)


        List<Figure> figures = new ArrayList<>(); // воспользуемся ранее импортированным интерфейсом List и объявим динамический массив figures, который будет хранить объекты типа(согласно интерфейсу) Figure
        figures.add(new Triangle(3, 4)); // создадим и динамично добавим в массив объект класса Triangle с необходимыми нам параметрами
        figures.add(new Triangle(5, 10)); // создадим и динамично добавим в массив объект класса Triangle с необходимыми нам параметрами
        figures.add(new Square(4)); // создадим и динамично добавим в массив объект класса Square с необходимыми нам параметрами(ом)
        figures.add(new Square(7)); // создадим и динамично добавим в массив объект класса Square с необходимыми нам параметрами(ом)


        System.out.println("\n\n\nСписок всех фигур:"); // Выведем информационное сообщение для пользователя
        for (Figure figure : figures) { // определим цикл for, который будет выводить информацию о характеристиках всех объектов типа Figure
            figure.print_figure_info(); // вызываем метод print_figure_info() для конкретного объекта figure текущей итерации через точечную нотацию, тем самым выводя в консоль строчку с характеристиками объекта
        } // конец цикла for


        System.out.print("\n\n\nВведите площадь для сравнения: "); // Выведем сообщение для пользователя приглашающее ввести параметр для сравнения
        double the_comparison_value = scanner.nextDouble(); // запишем в переменную the_comparison_value типа double используя метод nextDouble() объекта scanner класса Scanner


        System.out.print("\n\n\nВывести фигуры:\n" // спросим пользователя в какую сторону искать и предложим варианты ответа
        + "[1] - с большей площадью\n"
        + "[0] - с меньшей площадью\n");
        boolean looking_for_bigger_value = scanner.nextInt() == 1; // запишем ответ пользоватяля в переменную looking_for_bigger_value типа boolean используя метод nextInt() объекта scanner класса Scanner

        
        System.out.println("\n\n\nФигуры, соответствующие критерию:"); // выведем информационное сообщение для пользователя
        SearchInfo.filter_figures(figures, the_comparison_value, looking_for_bigger_value); // вызовем метод filter_figures() класса SearchInfo и передадим туда требуемые для работы аргументы. что приведет к выводу информации о подходящих по характеристикам объектах типа Figure

        scanner.close(); // закрываем объект scanner и освобождаем реусрсы системы
    } // конец главного метода main()
} // конец главного класса Main
