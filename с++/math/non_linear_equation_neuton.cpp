#include <iostream> // подключаем стандартную библиотеку ввода-вывода в С++
#include <cmath> // подключаем стандартную библиотеку для работы с матеметическими функциями в С++
#include <iomanip> // подключаем стандартную библиотеку для управлением форматированием в С++

using namespace std; // укажем компилятору, что мы используем пространство имен std по умолчанию, для удобочитаемости кода


double f(double x) { // объявим рабочую функцию f согласно условия задачи которая будет принимать аргумент типа double и возвращать число типа double
    return x + sqrt(x) + cos(2 * x) - 3; // возвращаем вычисленной значение функции f(x)
} // закрывающая скобка функции f

double df(double x) { // объявим функцию df которая будет вычислять производную функции f(x)
    return 1 + (1 / (2 * sqrt(x))) - 2 * sin(2 * x);  // вернем результат вычисления математического представления производной функции f(x)
} // закрывающая скобка функции df


double non_linear_eq_by_newton(double x_start, double tol, int max_iter) { // объявим функцию для проведения вычислений по методу Ньютона. Вернем найденный корень уравнения типа double 
    double x = x_start; // создадим переменную x для выполнения расчетов. Передадим в нее начальное значение x_start
    for (int i = 0; i < max_iter; i++) { // задекларируем цикл, который выполнит расчеты по методу Ньютона max_iter итераций
        double fx = f(x); // вызовем ранее объявленную функцию f, вычислим, запишем результат в переменную fx типа double
        double dfx = df(x); // вызовем ранее объявленную функцию df, вычислим, запишем результат в переменную dfx типа double
        
        if (fabs(dfx) < 1e-10) { // условие, которое сравнивает получившуюся произволную(eё модуль) с очень маленьким числом. метод Ньютона даст ошибку в случае если производная будет близка к нулю 
            cout << "Исключительный случай - слишком близкое к 0 значение производной, вычисление по методу Ньютона не даст осмысленного результата." << endl; // сообщим, что у нас исключительный случай
            return NAN; // завершим выполнение функции и вернем NAN, так как метод неприменим
        } // закрываюшая скобка фильтрующего условия

        double x_next = x - fx / dfx; // прозведем вычисления по формуле метода Ньютона x_next==x-f(x)/f'(x) и сохраним в переменную x_next, которая временно хранит новое приближение корня

        if (fabs(x_next - x) < tol) { // условие проверки на достижение необходимой точности. В случае если заданная изначально погрешность достигнута, то вернем текущий корень
            return x_next; // возвращаем x_next, текущий посчитанный по методу Ньютона корень, с допустимой для нас погрешностью согласнно заданного порога сходимости tol
        } // закрывающая скобка проверяющего условия

        x = x_next; // заходим на новую итерацию, если не прошли проверку на допустимую погрешность
    } // закрывающая скобка цикла for, уточняюшего x до достижения необходимого порога сходимости

    cout << "За " << max_iter << " итераций не удалось найти корня по методу Ньютона, удовлетворяющему условию порога сходимости." << endl; // выводим сообщение, что за заданное число итераций не удалось найти корень, удовлетворяющий условиям порога сходимости
    return NAN; // возвращаем NAN
} // закрывающая скобка функции

int main() { // объявляем главную функцию-точку входа в программу
    double x_start = 2.0; // объявим переменную x_start для хранения начального приближения для метода Ньютона
    double tol = 1e-6; // объявим переменную tol для хранения порога допустимой погрешности при расчете приближенного корня по методу Ньютона
    int max_iter = 100; // объявим переменную max_iter для хранения числа максимальных итераций в цикле при расчете приближенного корня по методу Ньютона
    
    
    double root = non_linear_eq_by_newton(x_start, tol, max_iter); // вызвем функцию non_linear_eq_by_newton для нахождения приближенного корня уравнения по методу Нъютона, после чего запишем в переменную root типа double

    if (!isnan(root)) { // условие-проверка на наличие ошибок, в функции non_linear_eq_by_newton мы заложили возврат значения NAN в том случае если чтото идет не так
        cout << "Найденный корень: " << fixed << setprecision(6) << root << endl; // выводим строку с найденным корнем
        cout << "Результат проверки с найденным корнем = " << fixed << setprecision(6) << f(root) << endl; // выводим строку с проверкой
    } else { // ветвление условия
        cout << "Корень не найден." << endl; // если у нас NAN то пишем что корень не найден
    } // закрывающая скобка условия

    return 0; // вернем код успещного выполнения программы
} // конец главной функции main
