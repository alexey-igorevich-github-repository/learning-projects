#include <iostream> // подключаем библиотеку для ввода-вывода данных в консоль
#include <cmath> // подключаем библиотеку для работы с математикой
#include <vector> // подключаем библиотеку для использования динамических массивов

using namespace std; // уберем у стандартных библиотек префикс ::std ради читабельности

double f(double x) { // задекларируем нашу функцию с названием  f, она будет возвращать число типа double, передаваемый аргумент тоже будет double
    return sqrt(x * x) * cos(x); // вернем математический расчет нашей функции f(x) = sqrt(x^2) * cos(x)
} // закрывающая фигурная скобка конец функции f

double vichislenie_integrala_metodom_trapeciy(double a, double b, int n) { // задекларируем функцию для вычисления интеграла методом трапеций, а также определим передаваемые аргументы. Пропишем подходящие типы числовых значений.
    double h = (b - a) / n; // Вычисление ширины подотрезка(шага разбиения) h с типом значения double 
    double integral = 0.0; // Определим переменную для суммирования значения интеграла, обнулим ее до начала серии вычислений

    integral += (f(a) + f(b)) / 2.0; // рассчитаем значение функции в крайних точках, применим коэффициент 1 разделив на 2 и приплюсуем в переменную integral

    for (int i = 1; i < n; i++) { // теперь создадим цикл, который будет считать значение функции для внутренних точек разбиения в зависимости от их количества. Соответственно от 1 до n пока n меньше счетчика i
        double x = a + i * h; // вычислим очередную точку разбиения относительно точки a, номера разбиения по счетчику i, значения длинны подотрезка на который будем умножать счетчик
        integral += f(x); // вычислим интеграл для текущей точки разбиения и приплюсуем в общую сумму
    } // фигурная скобка конец цикла

    integral *= h; // домножим на шаг разбиения(ширину подотрезка) согласно формулы метода трапеций

    return integral; // вернем посчитанное значение интеграла
} // конец функции vichislenie_integrala_metodom_trapeciy

int main() { // объявим главную функцию которая оркестрирует выполнение программы, вернем int с кодом выполнения
    double a = -3, b = 3; // объявим переменные a и b представляющие собой крайние точки. подставим данные из задания.
    
    vector<int> n_list = {15, 20, 150, 650}; // объявим  целочисленный массив используя класса vector. заполним его согласно заданию.

    double the_most_precise_result = 0.0; // Объявим переменные для хранения результата вычисления
    int the_biggest_n = 0; // объявим переменную для хранения n при котором получается наиболее точный результат

    for (int n : n_list) { // создадим цикл для прохода по массиву n_list 
        double result = vichislenie_integrala_metodom_trapeciy(a, b, n); // вызываем функцию vichislenie_integrala_metodom_trapeciy с заданными статичными аргументами и текущим n, после чего записываем в result
        cout << "Определенный интеграл от функции f(x)=√x² * cos_x методом трапеций при a = " << a << ", b = " << b << ", n = " << n << " равняется: " << result << endl; // выведем в консоль результат текущей итерации для текущего n. поставим перенос строки.

        if (n > the_biggest_n) { // самый точный результат будет при большем числе разбиений, нам нужна больщая n. Создадим условие, что если текущее n окажется больше того, что уже записано в переменную the_biggest_n то мы ее перезапишем. И соответственно, наиболее точный результат запомним другой для вывода в конце.
            the_biggest_n = n; // перезапись переменной для самого большого n          
            the_most_precise_result = result; // перезапись переменной для самого точного результата
        } // закроем условие

    } // закроем цикл for

    cout << "\nСамое точное приближенное значение интеграла будет при n = " << the_biggest_n << " и равняется: " << the_most_precise_result << endl; // Выведем лучший результат при самом большом n и перенесем строку.

    return 0; // вернем код завершения программы
} // закрывающая скобка главной функции
