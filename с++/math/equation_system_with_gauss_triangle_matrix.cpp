#include <iostream> // подключим библиотеку стандартных функций С++ для потокового ввода-вывода
#include <vector> // подключим библиотеку стандартных функций С++ для работы с динамическими массивами (векторами)
#include <iomanip> // подключим библиотеку стандартных функций С++ для форматирования данных

using namespace std; // добавим возможность не писать std:: перед стандартными функциями ради облегчения читаемости кода

int main() { // создадим главную функцию-точку входа, которая будет возвращать int (целочисленный код результата выполнения программы)
    vector<vector<double>> A = { // объявим двумерный динамический массив-вектор для хранения информации о нашей системе линейных уравнений

        {1, 5, 4, 2, 0}, // создаем вложенный одномерный vector<double>, который представляет одну строку в матрице. A[0] – это одномерный массив-вектор {1, 5, 4, 2, 0}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [0][0] индекс-индекс.
        {5, 0, 5, -1, 5}, // создаем вложенный одномерный vector<double>, который представляет одну строку в матрице. A[1] – это одномерный массив-вектор {5, 0, 5, -1, 5}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [1][0] индекс-индекс.
        {-3, -2, -1, -2, 1}, // создаем вложенный одномерный vector<double>, который представляет одну строку в матрице. A[2] – это одномерный массив-вектор {-3, -2, -1, -2, 1}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [2][0] индекс-индекс.
        {-3, 0, 2, 1, 2}, // создаем вложенный одномерный vector<double>, который представляет одну строку в матрице. A[3] – это одномерный массив-вектор {-3, 0, 2, 1, 2}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [3][0] индекс-индекс.
        {1, 6, 5, 4, 5} // создаем вложенный одномерный vector<double>, который представляет одну строку в матрице. A[4] – это одномерный массив-вектор {1, 6, 5, 4, 5}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [4][0] индекс-индекс.
    }; // конец описания двумерного динамического массива-вектора vector<vector<double>> A, в котором мы храним коэффициенты переменных (левую-часть системы уравнений)

    vector<double> B = {24, -1, -28, -24, 14}; // описание одномерного динамического массива-вектора B, в котором мы храним свободные члены (правую часть системы уравнений)
    
    int n = B.size(); // объявим переменную в которой будем хранить размер массива B

    for (int i = 0; i < n; i++) { // объявим цикл для прохода по строкам матрицы. будем приводить матрицу к треугольному виду
        int maxRow = i; // объявим переменную для хранения номера строки, пока что запишем номер текущей строки, который будет заменен на номер строки, в которой в данном столбце окажется максимальный коэффициент
        for (int k = i + 1; k < n; k++) { // декларирование вложенного цикла. будем проходить по строкам ниже той, что i и будем искать новый максимальный коэффициент в строках ниже. 
            if (abs(A[k][i]) > abs(A[maxRow][i])) { // (если A[k][i]  > текущего A[maxRow][i] то 
                maxRow = k; // перезапишем maxRow )
            } // конец условия для перезаписи maxRow
        } // конец вложенного цикла для прохода по строкам ниже i (того у которого счетчик k)
        swap(A[i], A[maxRow]); // поменяем местами (свапнем) элементы массива представляющие собой строки в левой части. 
        swap(B[i], B[maxRow]); // поменяем местами (свапнем) элементы массива представляющие собой строки в правой части.

        double diag = A[i][i]; // создадим переменную с типом double для хранения значений элементов главной диагонали
        for (int j = i; j < n; j++) { // декларирование еще одного вложенного цикла для прохождения по элементам строки i матрицы A начиная со столбца i
            A[i][j] /= diag; // начинаем нормализовывать строку начиная от элемента расположенного на главной диагонали
        } // закрывающая скобка для внутреннего цикла нормализации строки 
        B[i] /= diag; // и теперь нормализуем соответствующее строке из массива A элемент из массива B

        for (int k = i + 1; k < n; k++) { // начало еще одного вложенного цикла, который обнуляет элементы под ведущим (строки ниже) для получения нулевой нижней части треугольной матрицы. i текущая нормализованная, мы будем брать i + 1
            double factor = A[k][i]; // создадим переменную для хранения числа используемого как множитель при обнулении
            for (int j = i; j < n; j++) { // пройдемся по элементам строки что ниже с помощью вложенного-вложенного цикла и обнулим приближая матрицу к треугольному виду
                A[k][j] -= factor * A[i][j]; // каждому значению нижней строки k столбца итерации вложеного-вложенного цикла j присвоим: отминусованное от него произведение factor(множитель) на элемент вышестоящей строки. Таким образом всю строку отминусуем на домноженную верхнуюю строку начиная с элемента на главной диагонали.
            } // закроем вложенный-вложенный цикл для движения по структуре представляющей собой строку матрицы между элементами, которые j
            B[k] -= factor * B[i]; // теперь одномерный массив B соответствующую строку отминусуем домножив на множитель
        } // закроем вложенный цикл для движения между нижестоящими чем строка i строками матрицы, которые k
    } // закроем внешний цикл для движения по строкам матрицы, которые i

    vector<double> un_vars_list(n); // объявим одномерный массив-вектор для хранения найденных в ходе обратного хода значений переменных
    for (int i = n - 1; i >= 0; i--) { // создадим цикл для прохода снизу вверх, будем решать систему в обратном порядке
        un_vars_list[i] = B[i]; // вычислим-запишем/подумаем значение правой части строки i системы линейных уравнений из массива B, которая в первом проходе является значением первой неизвестной переменной по координатам [i][i]. Запишем в массив с найденными переменными для дальнейшего использования.
        for (int j = i + 1; j < n; j++) { // определим вложенный цикл для вычитания влияния уже найденных un_vars_list[j] из уравнения для правильного вычисления un_var_list[i]
            un_vars_list[i] -= A[i][j] * un_vars_list[j]; // очередная неизвестная будет вычислена путем отминусовывания произведения свежевычисленной переменной j и ее коэффициента из правой части вновь взятой строки i массива B. После чего будет записана в массив un_var_list под номером элемента [i] для дальнейшего использования.
        } // закрываем вложенный цикл
    } // закрываем основной цикл

    vector<char> un_var_names_list = {'x', 'y', 'z', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w'}; // создадим массив-словарь, в который положим названия переменных в формате задания лабораторной работы для удобочитаемости ответа ---> x y z p q r s t u v w

    cout << "\nОтвет:\n"; // перенесем строку, выведем сообщение "Ответ:" и перенесем строку
    for (int i = 0; i < n; i++) { // создадим цикл для вывода значений из массивов un_var_names_list и un_vars_list и формирования человекочитаемого ответа
        cout << un_var_names_list[i] << " = " << fixed << setprecision(6) << un_vars_list[i] << endl; // в каждой итерации выведем человекочитаемую часть ответа по очередной переменной с точностью 6 знаков после запятой
    } // конец цикла для вывода ответов

    return 0; // код успешного завершения программы
} // скобка закрывающая главную функцию main
