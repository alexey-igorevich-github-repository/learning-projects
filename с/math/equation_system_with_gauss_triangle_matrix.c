#include <stdio.h>  // подключим библиотеку стандартных функций С для потокового ввода-вывода
#include <stdlib.h> // подключим библиотеку стандатных функций С для работы с памятью, преобразованием данных и управлением программой
#include <math.h>   // подключим стандартную библиотеку С для работы с математическими функциями

int main() { // создадим главную функцию-точку входа, которая будет возвращать int (целочисленный код результата выполнения программы)

    //// объявим двумерный динамический массив для хранения информации о нашей системе линейных уравнений. Создаем массив указателей double* а потом выделяем память для каждой строки
    int n = 5; // объявим переменную в которой будем хранить размер левой части системы линейных уравнений А (получилось так что она 5х5) и размера массива B (правой части системы-уравнений)
    double** A = (double**)malloc(n * sizeof(double*)); // создадим указатель на указатель А, который будет хранить двумерный массив размера n*n. выделяем память с помощью malloc для n указателей на строки. Приводим указатель, возвращенный malloc к double**. Получаем динамический массив
    for (int i = 0; i < n; i++) { // теперь создадим цикл, который будет выделять память для каждой строки, итерируя выражение для выделения памяти n раз по числу строк в матрице/системе линейных уравнений
        A[i] = (double*)malloc(n * sizeof(double)); // Определим повдедение A[i] как одномерного массива. создадим указатель на i-тую строку двумерного массива А. Выделим память с помощью malloc для n элементов типа double. приводим дефолтный укзатель void* к double*
    } // закрывающая скобка цикла for

    double A_data[5][5] = { // объявляем статический двумерный массив который содержит 5х5 элементов типа double. массив будет использоваться в качестве источника данных для  массива А
        {1, 5, 4, 2, 0}, // создаем вложенный одномерный стандартный массив, который представляет одну строку в матрице. A_data[0] – это одномерный стандатрный массив {1, 5, 4, 2, 0}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [0][0] индекс-индекс.
        {5, 0, 5, -1, 5}, // создаем вложенный одномерный стандартный массив, который представляет одну строку в матрице. A_data[1] – это одномерный стандатрный массив {5, 0, 5, -1, 5}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [1][0] индекс-индекс.
        {-3, -2, -1, -2, 1}, // создаем вложенный одномерный стандартный массив, который представляет одну строку в матрице. A_data[2] – одномерный стандатрный массив {-3, -2, -1, -2, 1}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [2][0] индекс-индекс.
        {-3, 0, 2, 1, 2}, // создаем вложенный одномерный стандартный массив, который представляет одну строку в матрице. A_data[3] – это одномерный стандатрный массив {-3, 0, 2, 1, 2}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [3][0] индекс-индекс.
        {1, 6, 5, 4, 5} // создаем вложенный одномерный стандартный массив, который представляет одну строку в матрице. A[4_data] – это одномерный стандатрный массив {1, 6, 5, 4, 5}. Мы к нему через индекс обращаемся. А если нужно к элементам - то например [4][0] индекс-индекс.
    }; // конец описания двумерного статического стандартного массива  A_data, в котором мы храним коэффициенты переменных (левую-часть системы уравнений)

    for (int i = 0; i < n; i++) { // создадим цикл для прохода по строкам матрицы A_data и копирования ее значений в динамический массив A
        for (int j = 0; j < n; j++) { // создадим вложенный цикл для прохода по стролбцам матрицы A_data и копирования ее значений в динамический массив A
            A[i][j] = A_data[i][j]; // непосредственно само копирование i-строка j-столбец, получаются координаты, за счет двух циклов мы пройдемся по всем элементам левой части системы линейных уравнений, записанной левой частью матрицы.
        } // закроем цикл движения по столбцам
    } // закроем цикл движения по строкам

    //// описание одномерного динамического массива B, в котором мы храним свободные члены (правую часть системы уравнений)
    double* B = (double*)malloc(n * sizeof(double)); // объявим указатель B который будет указывать на динамический массив типа double. выделим память для n элементов типа double. приведем указатель возвращенный malloc() от void* к double*. получаем динамический массив
    double B_data[5] = {24, -1, -28, -24, 14}; // объявим стандартный одномерный массив B_data для хранения правой части системы линейных уравнений
    for (int i = 0; i < n; i++) { // создадим цикл для копирования массива B_data в динамический массив B
        B[i] = B_data[i]; // непосредственно само копирование
    } // закрываем цикл для копирования из одного массива в другой

    for (int i = 0; i < n; i++) { // объявим цикл для прохода по строкам матрицы. будем приводить матрицу к треугольному виду
        int maxRow = i; // объявим переменную для хранения номера строки, пока что запишем номер текущей строки
        for (int k = i + 1; k < n; k++) { // будем проходить по строкам ниже и искать новый максимальный коэффициент
            if (fabs(A[k][i]) > fabs(A[maxRow][i])) { // (если A[k][i]  > текущего A[maxRow][i] то 
                maxRow = k; // перезапишем maxRow )
            } // закроем условие
        }// закроем цикл for

        //// создадим механизм для меняния местами (свапа) строк в левой и правой частях матрицы
        double* tempA = A[i]; // объявляем указатель tempA который будет временно хранить адрес строки A[i]
        A[i] = A[maxRow]; // переназначаем указатель A[i] так, что i строка теперь указывает на maxRow строку
        A[maxRow] = tempA; // используя указатель tempA переназначаем указатель A[maxRow] так, что он теперь указывает на ту строку что первоначально указывал указатель A[i]. Тем самым благодаря третьему указателю мы провели свап строк и сделали шаг к построению треугольной матрицы.
        double tempB = B[i]; // объявляем указатель tempB который будет временно хранить адрес строки B[i]
        B[i] = B[maxRow]; // тоже самое что и с левой частью - теперь с правой частью. переназначаем указатели через третий указатель tempB
        B[maxRow] = tempB; // переназначили указатели теперь и в правой части матрицы

        double diag = A[i][i]; // создадим переменную для хранения значений элементов главной диагонали
        for (int j = i; j < n; j++) { // декларирование еще одного вложенного цикла для прохождения по элементам строки i матрицы A начиная со столбца i
            A[i][j] /= diag; // начинаем нормализовывать строку начиная от элемента расположенного на главной диагонали
        } // закрывающая скобка для внутреннего цикла нормализации строки
        B[i] /= diag; // нормализуем соответствующее строке из массива A элемент из массива B

        for (int k = i + 1; k < n; k++) { // начало еще одного вложенного цикла, который обнуляет элементы под ведущим (строки ниже) для получения нулевой нижней части треугольной матрицы. i текущая нормализованная, мы будем брать i + 1
            double factor = A[k][i]; // создадим переменную для хранения числа используемого как множитель при обнулении
            for (int j = i; j < n; j++) { // пройдемся по элементам строки что ниже с помощью вложенного-вложенного цикла и обнулим приближая матрицу к треугольному виду
                A[k][j] -= factor * A[i][j]; // каждому значению нижней строки k столбца итерации вложеного-вложенного цикла j присвоим: отминусованное от него произведение factor(множитель) на элемент вышестоящей строки. Таким образом всю строку отминусуем на домноженную верхнуюю строку начиная с элемента на главной диагонали.
            } // закроем вложенный-вложенный цикл для движения по структуре представляющей собой строку матрицы между элементами, которые j
            B[k] -= factor * B[i]; // теперь одномерный массив B соответствующую строку отминусуем домножив на множитель
        } // закроем вложенный цикл для движения между нижестоящими чем строка i строками матрицы, которые k
    } // закроем внешний цикл для движения по строкам матрицы, которые i

    double* un_vars_list = (double*)malloc(n * sizeof(double)); // объявим указатель un_vars_list который будет указывать на динамический массив c элементами типа double. выделим под них память, посчитав произведение нужного количества байт на n. После чего поменяем тип указателя с дефолтного void* на double*
    for (int i = n - 1; i >= 0; i--) { // создадим цикл для прохода снизу вверх, будем решать систему в обратном порядке "обратный ход метода Гаусса"
        un_vars_list[i] = B[i]; // вычислим-запишем/подумаем значение правой части строки i системы линейных уравнений из массива B, которая в первом проходе является значением первой неизвестной переменной по координатам [i][i]. Запишем в массив с найденными переменными для дальнейшего использования.
        for (int j = i + 1; j < n; j++) { // определим вложенный цикл для вычитания влияния уже найденных un_vars_list[j] из уравнения для правильного вычисления un_var_list[i]
            un_vars_list[i] -= A[i][j] * un_vars_list[j]; // очередная неизвестная будет вычислена путем отминусовывания произведения свежевычисленной переменной j и ее коэффициента из правой части вновь взятой строки i массива B. После чего будет записана в массив un_var_list под номером элемента [i] для дальнейшего использования.
        } // закрываем вложенный цикл
    } // закрываем основной цикл

    char un_var_names_list[] = {'x', 'y', 'z', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w'}; // создадим массив-словарь, в который положим названия переменных в формате задания лабораторной работы для удобочитаемости ответа ---> x y z p q r s t u v w

    printf("\nОтвет:\n"); // перенесем строку, выведем сообщение "Ответ:" и перенесем строку
    for (int i = 0; i < n; i++) {  // создадим цикл для вывода значений из массивов un_var_names_list и un_vars_list и формирования человекочитаемого ответа
        printf("%c = %.6f\n", un_var_names_list[i], un_vars_list[i]); // в каждой итерации выведем человекочитаемую часть ответа по очередной переменной с точностью 6 знаков после запятой
    } // закрытие цикла для построчного вывода ответа

    //// блок освобождения памяти
    free(B);  // для избежания утечки, освободим память, выделенную для указателя B с помощью malloc()
    free(un_vars_list); // для избежания утечки, освободим память, выделенную для указателя un_vars_list с помощью malloc()
    for (int i = 0; i < n; i++) { // запускаем цикл для построчного освобождения памяти из элементов массива А
        free(A[i]); // освобождаем память зарезервированную под укзатель A[i], которые являли собой строки в динамическом массиве А
    } // конец цикла для прохода по массиву А
    free(A); // освобожаем память, выделенную для указателя А, который являл собой двумерный динамический массив

    return 0; // код успешного завершения программы
} // закрывающая скобка главной функции main