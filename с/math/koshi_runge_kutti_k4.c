#include <stdio.h> // подключим стандартную библиотеку С для использования функций ввода-вывода
#include <math.h> // подключим стандартную библиотеку С для использования математический функций


double f(double x, double y) { // объявим функцию f(x,y) задающую наше уравнение и которая будет возвращать правую часть дифференциального уравнения. далее будем использовать ее для вычисления коэффициентов k1 k2 k3 k4
    return ((x + 1) / x) * exp(x) - (y / x); // вычислим правую часть дифференциального уравнения - значение y' в данной точке (x,y) ---> возвращаем значение производной y' 
} // закрывающая скобка функции f(x,y)

void integr_runge_kutta_4k(double x_start, double y_start, double h, double x_end) { // объявим функцию для выполнения расчетов по методу Рунге-Кутты согласно задания, функция возвращает void. В аргументах укажем исходные данные задачи с типом double
    double x = x_start; // объявим переменную x типа double и зададим ей начальное значение исходя из условий задачи
    double y = y_start; // объявим переменную y типа double и зададим ей начальное значение исходя из условий задачи
    
    //// Дабы не усложнять и не заниматься выделением памяти - выводить результаты будем походу расчета.
    printf(" x | y(x) прибл-Р-К-4 | y(x)=e^x проверка | Δ по модулю гр.2-гр.3 погрешность \n"); // нарисуем шапку таблицы в консоли, перенесем строку
    printf("----------------------------------------------------\n"); // нарисуем разделитель в консоли, перенесем строку
    printf("%.6f | %.6f | %.6f | %.6f\n", x, y, exp(x), fabs(y - exp(x))); // выведем начальные значения и рассчитаную проверку с точностью 6 знаков после запятой и перенесем строку
    
    while (x < x_end) { // задекларируем цикл while для вычисления коэффициентов по методу Рунге-Кутты, количество итерации в данном варианте цикла зависит от исходных значение x_start x_end и шага h
        double k1 = h * f(x, y); // объявим переменную k1 типа double для хранения вычисленного коэффициента 1 порядка по методу Рунге-Кутты (первый самый быстрый и самый грубый прогноз), на его основе строится следующий уточненный k2
        double k2 = h * f(x + h / 2, y + k1 / 2); // объявим переменную k2 типа double для хранения вычисленного коэффициента 2 порядка по методу Рунге-Кутты. Вычисляем значение f(x,y) в середине отрезка [x,x+h].Считаем что x продвинулся на половину шага h/2. Значение y тоже сдвигаем y+k1/2. Итак k2 по сравнению с k1 учитывает влияние изменения функции в середине шага. (поточнее, еще не сильно расходует вычислительную мощность)
        double k3 = h * f(x + h / 2, y + k2 / 2); // объявим переменную k3 типа double для хранения вычисленного коэффициента 3 порядка по методу Рунге-Кутты. Еще больше уточним прогноз по тойже схеме, что и при расчете k2. Только теперь вместо k1 используем уже скорректированное значение k2. 
        double k4 = h * f(x + h, y + k3); // объявим переменную k4 типа double для хранения вычисленного коэффициента 4 порядка по методу Рунге-Кутты. При расчете k4 двигаем x на полный шаг h, для y берем значение скорректированоое через k3. Это финальная коррекция метода Рунге-Кутты, которая дает полную карину изменения y(x) на шаге

        y += (k1 + 2 * k2 + 2 * k3 + k4) / 6; // обновим значение y используя усредненое значение коэффициентов k1,k2,k3,k4. y становится более точным
        x += h; // увеличим x на шаг h чтобы перейти к следующей точке расчета

        printf("%.6f | %.6f | %.6f | %.6f\n", x, y, exp(x), fabs(y - exp(x))); // выведем текущие значения и рассчитаную проверку с точностью 6 знаков после запятой, перенесем строку, после чего пойдем на новую итерацию
    } // конец цикла 
} // закрывающая скобка вызываемой функции


int main() { // объявим главную функцию-точку входа с которой начинается выполнение программы
    double x_start = 1.0; // определяем переменную для хранения начального значения x с типом double
    double y_start = exp(1); // определяем переменную для хранения начального значения функции y(x) c типом double
    double h = 0.1; // определим переменную для хранения значения шага интегрирования с типом double
    double x_end = 2.0; // определяем переменную для хранения конечного значения x до которого идет расчет с типом double
    
    integr_runge_kutta_4k(x_start, y_start, h, x_end); // вызвовем фунцию  integr_runge_kutta_4k с сохраненными аргументами согласно задания
    
    return 0; // вернем целочисленный код успешного выполнения программы
} // закрывающа скобка конец главной функции
