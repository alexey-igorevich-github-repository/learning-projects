#include <iostream> // подключим библиотеку iostream, требуемую для работы с вводом выводом
#include <cmath> // подключим библиотеку для работы с математическими функциями в С++
#include <vector> // подключим библиотеку для работы с динамическими массивами в С++
#include <iomanip> // библиотека для форматирования вывода чисел в С++

using namespace std; // для облегчения кода отключим обязательное упоминание имени библиотеки перед объектами, у нас мало библиотек и пересечений не будет


double f(double x, double y) { // объявим функцию f(x,y) задающую наше уравнение и которая будет возвращать правую часть дифференциального уравнения. далее будем использовать ее для вычисления коэффициентов k1 k2 k3 k4
    return ((x + 1) / x) * exp(x) - (y / x); // вычислим правую часть дифференциального уравнения - значение y' в данной точке (x,y) ---> возвращаем значение производной y' 
} // закрывающая скобка функции f(x,y)

// Метод Рунге-Кутты 4-го порядка
vector<pair<double, double>> integr_runge_kutta_4k(double x_start, double y_start, double h, double x_end) { // объявим функцию rungeKutta которая будет возвращать динамический массив-вектор пар чисел (x,y). В аргументах укажем исходные данные задачи с типом double
    vector<pair<double, double>> results; // создадим массив-вектор results который будет хранить пары (x,y) являющиеся результатом вычислений
    double x = x_start; // объявим переменную x типа double и зададим ей начальное значение исходя из условий задачи
    double y = y_start; // объявим переменную y типа double и зададим ей начальное значение исходя из условий задачи

    results.push_back({x, y}); // используя метод push_back() из библиотеки std::vector добавляем новую пару значений в динамический массив-вектор results, в котором хранится таблица вычисленных значений по Рунге-Кутты

    while (x < x_end) { // задекларируем цикл while для вычисления коэффициентов по методу Рунге-Кутты, количество итерации в данном варианте цикла зависит от исходных значение x_start x_end и шага h
        double k1 = h * f(x, y); // объявим переменную k1 типа double для хранения вычисленного коэффициента 1 порядка по методу Рунге-Кутты (первый самый быстрый и самый грубый прогноз), на его основе строится следующий уточненный k2
        double k2 = h * f(x + h / 2, y + k1 / 2); // объявим переменную k2 типа double для хранения вычисленного коэффициента 2 порядка по методу Рунге-Кутты. Вычисляем значение f(x,y) в середине отрезка [x,x+h].Считаем что x продвинулся на половину шага h/2. Значение y тоже сдвигаем y+k1/2. Итак k2 по сравнению с k1 учитывает влияние изменения функции в середине шага. (поточнее, еще не сильно расходует вычислительную мощность)
        double k3 = h * f(x + h / 2, y + k2 / 2); // объявим переменную k3 типа double для хранения вычисленного коэффициента 3 порядка по методу Рунге-Кутты. Еще больше уточним прогноз по тойже схеме, что и при расчете k2. Только теперь вместо k1 используем уже скорректированное значение k2. 
        double k4 = h * f(x + h, y + k3); // объявим переменную k4 типа double для хранения вычисленного коэффициента 4 порядка по методу Рунге-Кутты. При расчете k4 двигаем x на полный шаг h, для y берем значение скорректированоое через k3. Это финальная коррекция метода Рунге-Кутты, которая дает полную карину изменения y(x) на шаге

        y += (k1 + 2 * k2 + 2 * k3 + k4) / 6; // обновим значение y используя усредненое значение коэффициентов k1,k2,k3,k4. y становится более точным
        x += h; // увеличим x на шаг h чтобы перейти к следующей точке расчета

        results.push_back({x, y}); // сохраним новую точку в динамический массив-вектор results (до начала новой итерации)
    } // конец цикла 
    return results; // возвращаем результаты вычислений (все вычисленные точки (x,y)), хранящиеся в динамическом массиве-векторе results
} // закрывающая скобка вызываемой функции

int main() { // объявим главную функцию с которой начинается выполнение программы, вернем целочисленное значение в конце работы
    double x_start = 1.0; // определяем переменную для хранения начального значения x с типом double
    double y_start = exp(1); // определяем переменную для хранения начального значения функции y(x) c типом double
    double h = 0.1; // определим переменную для хранения значения шага интегрирования с типом double
    double x_end = 2.0; // определяем переменную для хранения конечного значения x до которого идет расчет с типом double

    vector<pair<double, double>> integr_results_list = integr_runge_kutta_4k(x_start, y_start, h, x_end); // создадим динамический массив-вектор для хранения результатов вычисления функции integr_runge_kutta_4k

    //// блок вывода результатов
    cout << fixed << setprecision(6); // установим точность чисел до 6 знаков после запятой
    cout << " x | y(x) прибл-Р-К-4 | y(x)=e^x проверка | Δ по модулю гр.2-гр.3 погрешность " << endl; // нарисуем шапку таблицы в консоли
    cout << "------------------------------------------" << endl; // нарисуем разделитель в консоли
    
    for (auto &[x, y] : integr_results_list) { // задекларируем цикл для прохода по всем рассчитаным точкам (x,y) и выводу их в консоль
        double exact_check_value = exp(x); // вычисляем точное значение на основе того, что дано в задании. записываем в переменную exact
        double math_error = abs(y - exact_check_value); // вычисляем погрешность. записываем в переменную error
        cout << x << " | " << y << " | " << exact_check_value << " | " << math_error << endl; // выводим результаты в соответствующих графах таблицы
    } // закрывающая скобка цикла
    
    return 0; // вернем целочисленный код успешного выполнения программы
} // закрывающа скобка конец главной функции
